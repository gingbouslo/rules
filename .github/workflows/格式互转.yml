name: Full Robust Rule Converter (YAML/JSON/TEXT) - Final

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "选择转换模式 (12 options)"
        required: true
        type: choice
        options:
          - domain-yaml2json
          - domain-yaml2text
          - domain-json2yaml
          - domain-json2text
          - domain-text2yaml
          - domain-text2json
          - ip-yaml2json
          - ip-yaml2text
          - ip-json2yaml
          - ip-json2text
          - ip-text2yaml
          - ip-text2json

jobs:
  convert:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install tools (jq)
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq jq

      - name: Convert according to mode
        env:
          MODE: ${{ github.event.inputs.mode }}
        run: |
          set -euo pipefail
          CD_DIR="change"
          mkdir -p "$CD_DIR"
          cd "$CD_DIR" || exit 1

          # ---------------------------
          # clean_line: remove surrounding spaces and quotes
          # ---------------------------
          clean_line() {
            local line="$1"
            # Trim leading/trailing whitespace
            line="${line#"${line%%[![:space:]]*}"}"
            line="${line%"${line##*[![:space:]]}"}"
            # Remove leading bullets/extra dashes/stars and common YAML key prefixes like "domain:", "rule:" etc.
            # Remove any leading non-alphanumeric characters except + and . and digits
            # But keep internal characters (we will strip leading +. later)
            # Remove common key patterns
            line="$(echo "$line" | sed -E 's/^[[:space:]]*[-\*\+]*[[:space:]]*//; s/^[[:space:]]*[a-zA-Z0-9_-]+:[[:space:]]*//')"
            # Remove surrounding single or double quotes
            if [[ "${line:0:1}" == "'" && "${line: -1}" == "'" ]] || [[ "${line:0:1}" == '"' && "${line: -1}" == '"' ]]; then
              line="${line:1:-1}"
            fi
            # Trim again
            line="${line#"${line%%[![:space:]]*}"}"
            line="${line%"${line##*[![:space:]]}"}"
            # remove extra leading characters like multiple dashes
            line="$(echo "$line" | sed -E 's/^[^[:alnum:]\+]*//')"
            printf "%s" "$line"
          }

          # ---------------------------
          # normalize_domain: remove leading +., *. and surrounding quotes/spaces -> returns domain without +.
          # ---------------------------
          normalize_domain() {
            local d
            d="$(clean_line "$1")"
            # Remove leading +. or *.
            d="$(echo "$d" | sed -E 's/^[[:space:]]*([+*]{0,2}\.)+//')"
            # If someone still put leading . remove
            d="$(echo "$d" | sed -E 's/^[.]+//')"
            printf "%s" "$d"
          }

          # ---------------------------
          # normalize_ip: strip quotes/spaces
          # ---------------------------
          normalize_ip() {
            local ip
            ip="$(clean_line "$1")"
            printf "%s" "$ip"
          }

          # Helper: build jq array from bash lines (lines provided via stdin)
          build_json_array_from_stdin() {
            # reads lines from stdin, outputs a JSON array literal
            jq -Rn '[inputs|select(length>0)]' < <(while IFS= read -r l; do
              # print each as raw string for jq to read
              printf '%s\n' "$l"
            done)
          }

          # ---------------------------
          # domain: yaml -> json
          # ---------------------------
          if [[ "$MODE" == "domain-yaml2json" ]]; then
            shopt -s nullglob
            for f in *_domain.yaml; do
              echo "Processing $f -> ${f%.yaml}.json"
              out="${f%.yaml}.json"
              # extract lines, clean and normalize
              tmpfile="$(mktemp)"
              while IFS= read -r line || [[ -n "$line" ]]; do
                v="$(normalize_domain "$line")"
                # skip empties and lines that are not domain-like
                if [[ -n "$v" && "$v" == *.* ]]; then
                  printf '%s\n' "$v" >> "$tmpfile"
                fi
              done < "$f"
              # build json array
              if [[ -s "$tmpfile" ]]; then
                arr=$(jq -R -s -c 'split("\n")[:-1]' < "$tmpfile")
                jq -n --argjson arr "$arr" '{version:2, rules:[{domain_suffix:$arr}]}' > "$out"
              else
                echo "No domain entries found in $f"
                rm -f "$tmpfile"
                continue
              fi
              rm -f "$tmpfile"
            done
          fi

          # ---------------------------
          # domain: yaml -> text
          # ---------------------------
          if [[ "$MODE" == "domain-yaml2text" ]]; then
            shopt -s nullglob
            for f in *_domain.yaml; do
              echo "Processing $f -> ${f%.yaml}.text"
              out="${f%.yaml}.text"
              : > "$out"
              while IFS= read -r line || [[ -n "$line" ]]; do
                v="$(normalize_domain "$line")"
                if [[ -n "$v" && "$v" == *.* ]]; then
                  echo "$v" >> "$out"
                fi
              done < "$f"
            done
          fi

          # ---------------------------
          # domain: json -> yaml
          # ---------------------------
          if [[ "$MODE" == "domain-json2yaml" ]]; then
            shopt -s nullglob
            for f in *_domain.json; do
              echo "Processing $f -> ${f%.json}.yaml"
              out="${f%.json}.yaml"
              echo "payload:" > "$out"
              # read domain list from json (rules[0].domain_suffix)
              jq -r '.rules[0].domain_suffix[]' "$f" 2>/dev/null | while IFS= read -r d || [[ -n "$d" ]]; do
                d_clean="$(normalize_domain "$d")"
                if [[ -n "$d_clean" ]]; then
                  echo "  - +.$d_clean" >> "$out"
                fi
              done
            done
          fi

          # ---------------------------
          # domain: json -> text
          # ---------------------------
          if [[ "$MODE" == "domain-json2text" ]]; then
            shopt -s nullglob
            for f in *_domain.json; do
              echo "Processing $f -> ${f%.json}.text"
              out="${f%.json}.text"
              : > "$out"
              jq -r '.rules[0].domain_suffix[]' "$f" 2>/dev/null | while IFS= read -r d || [[ -n "$d" ]]; do
                d_clean="$(normalize_domain "$d")"
                if [[ -n "$d_clean" ]]; then
                  echo "$d_clean" >> "$out"
                fi
              done
            done
          fi

          # ---------------------------
          # domain: text -> yaml
          # ---------------------------
          if [[ "$MODE" == "domain-text2yaml" ]]; then
            shopt -s nullglob
            for f in *_domain.text; do
              echo "Processing $f -> ${f%.text}.yaml"
              out="${f%.text}.yaml"
              echo "payload:" > "$out"
              while IFS= read -r line || [[ -n "$line" ]]; do
                v="$(normalize_domain "$line")"
                if [[ -n "$v" ]]; then
                  echo "  - +.$v" >> "$out"
                fi
              done < "$f"
            done
          fi

          # ---------------------------
          # domain: text -> json
          # ---------------------------
          if [[ "$MODE" == "domain-text2json" ]]; then
            shopt -s nullglob
            for f in *_domain.text; do
              echo "Processing $f -> ${f%.text}.json"
              out="${f%.text}.json"
              tmpfile="$(mktemp)"
              while IFS= read -r line || [[ -n "$line" ]]; do
                v="$(normalize_domain "$line")"
                if [[ -n "$v" ]]; then
                  printf '%s\n' "$v" >> "$tmpfile"
                fi
              done < "$f"
              if [[ -s "$tmpfile" ]]; then
                arr=$(jq -R -s -c 'split("\n")[:-1]' < "$tmpfile")
                jq -n --argjson arr "$arr" '{version:2, rules:[{domain_suffix:$arr}]}' > "$out"
              else
                echo "No domain entries in $f"
              fi
              rm -f "$tmpfile"
            done
          fi

          # ---------------------------
          # ip: yaml -> json
          # ---------------------------
          if [[ "$MODE" == "ip-yaml2json" ]]; then
            shopt -s nullglob
            for f in *_ip.yaml; do
              echo "Processing $f -> ${f%.yaml}.json"
              out="${f%.yaml}.json"
              tmpfile="$(mktemp)"
              while IFS= read -r line || [[ -n "$line" ]]; do
                v="$(normalize_ip "$line")"
                # simple validation: must contain a slash for CIDR or look like an IP
                if [[ -n "$v" && "$v" == */* ]]; then
                  printf '%s\n' "$v" >> "$tmpfile"
                fi
              done < "$f"
              if [[ -s "$tmpfile" ]]; then
                arr=$(jq -R -s -c 'split("\n")[:-1]' < "$tmpfile")
                jq -n --argjson arr "$arr" '{version:2, rules:[{ip_cidr:$arr}]}' > "$out"
              else
                echo "No ip entries found in $f"
              fi
              rm -f "$tmpfile"
            done
          fi

          # ---------------------------
          # ip: yaml -> text
          # ---------------------------
          if [[ "$MODE" == "ip-yaml2text" ]]; then
            shopt -s nullglob
            for f in *_ip.yaml; do
              echo "Processing $f -> ${f%.yaml}.text"
              out="${f%.yaml}.text"
              : > "$out"
              while IFS= read -r line || [[ -n "$line" ]]; do
                v="$(normalize_ip "$line")"
                if [[ -n "$v" && "$v" == */* ]]; then
                  echo "$v" >> "$out"
                fi
              done < "$f"
            done
          fi

          # ---------------------------
          # ip: json -> yaml
          # ---------------------------
          if [[ "$MODE" == "ip-json2yaml" ]]; then
            shopt -s nullglob
            for f in *_ip.json; do
              echo "Processing $f -> ${f%.json}.yaml"
              out="${f%.json}.yaml"
              echo "payload:" > "$out"
              jq -r '.rules[0].ip_cidr[]' "$f" 2>/dev/null | while IFS= read -r d || [[ -n "$d" ]]; do
                d_clean="$(normalize_ip "$d")"
                if [[ -n "$d_clean" ]]; then
                  echo "  - $d_clean" >> "$out"
                fi
              done
            done
          fi

          # ---------------------------
          # ip: json -> text
          # ---------------------------
          if [[ "$MODE" == "ip-json2text" ]]; then
            shopt -s nullglob
            for f in *_ip.json; do
              echo "Processing $f -> ${f%.json}.text"
              out="${f%.json}.text"
              : > "$out"
              jq -r '.rules[0].ip_cidr[]' "$f" 2>/dev/null | while IFS= read -r d || [[ -n "$d" ]]; do
                d_clean="$(normalize_ip "$d")"
                if [[ -n "$d_clean" ]]; then
                  echo "$d_clean" >> "$out"
                fi
              done
            done
          fi

          # ---------------------------
          # ip: text -> yaml
          # ---------------------------
          if [[ "$MODE" == "ip-text2yaml" ]]; then
            shopt -s nullglob
            for f in *_ip.text; do
              echo "Processing $f -> ${f%.text}.yaml"
              out="${f%.text}.yaml"
              echo "payload:" > "$out"
              while IFS= read -r line || [[ -n "$line" ]]; do
                v="$(normalize_ip "$line")"
                if [[ -n "$v" ]]; then
                  echo "  - $v" >> "$out"
                fi
              done < "$f"
            done
          fi

          # ---------------------------
          # ip: text -> json
          # ---------------------------
          if [[ "$MODE" == "ip-text2json" ]]; then
            shopt -s nullglob
            for f in *_ip.text; do
              echo "Processing $f -> ${f%.text}.json"
              out="${f%.text}.json"
              tmpfile="$(mktemp)"
              while IFS= read -r line || [[ -n "$line" ]]; do
                v="$(normalize_ip "$line")"
                if [[ -n "$v" ]]; then
                  printf '%s\n' "$v" >> "$tmpfile"
                fi
              done < "$f"
              if [[ -s "$tmpfile" ]]; then
                arr=$(jq -R -s -c 'split("\n")[:-1]' < "$tmpfile")
                jq -n --argjson arr "$arr" '{version:2, rules:[{ip_cidr:$arr}]}' > "$out"
              else
                echo "No ip entries in $f"
              fi
              rm -f "$tmpfile"
            done
          fi

      - name: Commit & Push changes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "actions@github.com"
          git add change/*
          if git commit -m "Auto convert rules: ${{ github.event.inputs.mode }}"; then
            git push origin HEAD:main
          else
            echo "No changes to commit"
          fi
